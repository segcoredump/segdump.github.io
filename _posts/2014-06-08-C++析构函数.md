---
layout: post
title: "C++析构函数"
categories: 'c＋＋'
tags:

---

<h3>析构函数</h3>

析构函数用来自动回收或释放资源。析构函数是个成员函数，名字为在类名字之前加上一个代字号(~)，没有返回值，没有形参。由于不能指定任何形参，不能重载析构函数。
	
	#include <iostream>

    using namespace std;

    /*
     * 撤销类对象时自动调用析构函数。
     * 变量在超出作用域时自动撤销。
     *
     */ 
    class dest
    {
        public:
            dest(){}
            dest(const string& str):str(str){}

            /*
             * 析构函数与复制构造函数或复制操作符之间的一个重要区别是，
             * 即使我们编写了自己的析构函数，合成析构函数仍然运行。
             * 合成析构函数按对象创建时的逆序撤销每个非static成员。
             * 对于类类型的每个成员，合成析构函数调用该成员的析构函数来撤销对象。
             *
             * 合成析构函数不删除指针成员所指向的对象。
             *
             */ 
            ~dest()
            {
                cout<<"dest destructor"<<endl;
            }

        private:
            string str;
    };


    int main()
    {
        bool b=1;
        /*
         * 当对象的引用或指针超出作用域时，不会运行析构函数。
         * 只有删除指向动态分配对象的指针或实际对象（不是对象的引用）
         * 超出作用域时，才会运行析构函数。
         *
         */ 
        if(1==b)
        {
            dest *d=new dest();
            dest dt;         //离开if作用域时，自动运行析构函数

            //运行完自定义析构函数后，运行合成析构函数，调用string系够函数
            dest st("string");


            delete d;     //只有执行delete指针时，才运行析构函数
        }

        for(;;); 


        return 0;
    }


<h3>虚析构函数</h3>

	
*	自动调用基类部分的析构函数对基类的设计有重要影响。
	
*	删除指向动态分配对象的指针时，需要运行析构函数在释放对象的内存之前清除对象。处理继承层
	次中的对象时，指针的静态类型可能与被删除对象的动态类型不同，可能会删除实际指向派生类对
	象的基类类型指针。要保证运行适当的系够析构函数，基类中的析构函数必须为虚函数。